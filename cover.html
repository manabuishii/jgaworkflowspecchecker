
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>jgaworkflowspecchecker: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/manabuishiii/jgaworkflowspecchecker/main.go (14.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "bufio"
        "bytes"
        "crypto/md5"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "io"
        "io/ioutil"
        "log"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/xeipuuv/gojsonschema"
        "golang.org/x/sync/errgroup"

        // for CLI
        flag "github.com/spf13/pflag"
)

type RunData struct {
        PEOrSE  string `json:"se_or_pe"`
        FQ1     string `json:"fq1"`
        FQ1_MD5 string `json:"fq1_MD5"`
        FQ2     string `json:"fq2"`
        FQ2_MD5 string `json:"fq2_MD5"`
}

type Run struct {
        RunId string `json:"runid"`

        RunData `json:"data"`
}

type Sample struct {
        SampleId string `json:"sampleid"`
        Platform string `json:"platform"`
        RunList  []*Run `json:"runlist"`
}

type simpleSchema struct {
        Name string `json:"name"`

        SampleList []*Sample `json:"samplelist"`
}

// path and format
type PathObject struct {
        Path   string `json:"path"`
        Format string `json:"format"`
}

// path only
type PathOnlyObject struct {
        Path string `json:"path"`
}

type referenceSchema struct {
        WorkflowFile                           *PathOnlyObject `json:"workflow_file"`
        OutputDirectory                        *PathOnlyObject `json:"output_directory"`
        Reference                              *PathObject     `json:"reference"`
        SortsamMaxRecordsInRam                 int             `json:"sortsam_max_records_in_ram"`
        SortsamJavaOptions                     string          `json:"sortsam_java_options"`
        BwaNumThreads                          int             `json:"bwa_num_threads"`
        BwaBasesPerBatch                       int             `json:"bwa_bases_per_batch"`
        UseBqsr                                bool            `json:"use_bqsr"`
        Dbsnp                                  *PathObject     `json:"dbsnp"`
        Mills                                  *PathObject     `json:"mills"`
        KnownIndels                            *PathObject     `json:"known_indels"`
        SamtoolsNumThreads                     int             `json:"samtools_num_threads"`
        Gatk4HaplotypeCallerNumThreads         int             `json:"gatk4_HaplotypeCaller_num_threads"`
        BgzipNumThreads                        int             `json:"bgzip_num_threads"`
        HaplotypecallerAutosomePARIntervalBed  *PathObject     `json:"haplotypecaller_autosome_PAR_interval_bed"`
        HaplotypecallerAutosomePARIntervalList *PathOnlyObject `json:"haplotypecaller_autosome_PAR_interval_list"`
        HaplotypecallerChrXNonPARIntervalBed   *PathObject     `json:"haplotypecaller_chrX_nonPAR_interval_bed"`
        HaplotypecallerChrXNonPARIntervalList  *PathOnlyObject `json:"haplotypecaller_chrX_nonPAR_interval_list"`
        HaplotypecallerChrYNonPARIntervalBed   *PathObject     `json:"haplotypecaller_chrY_nonPAR_interval_bed"`
        HaplotypecallerChrYNonPARIntervalList  *PathOnlyObject `json:"haplotypecaller_chrY_nonPAR_interval_list"`
}

// nolint: gochecknoglobals
var (
        version  = "dev"
        revision = ""
        date     = ""
)

//

func md5File(filePath string) (string, error) <span class="cov3" title="3">{
        file, err := os.Open(filePath)

        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov3" title="3">defer file.Close()

        hash := md5.New()
        _, err = io.Copy(hash, file)

        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov3" title="3">return hex.EncodeToString(hash.Sum(nil)[:16]), nil</span>
}

func isExistsAllResultFilesPrefixRunId(outputDirectoryPath string, runId string) bool <span class="cov2" title="2">{
        result := true
        fn := filepath.Join(outputDirectoryPath, runId)
        for _, extension := range []string{".bam", ".bam.log"} </span><span class="cov3" title="4">{
                if _, err := os.Stat(fn + extension); os.IsNotExist(err) </span><span class="cov1" title="1">{
                        fmt.Printf("Missing file [%s]\n", fn+extension)
                        result = false
                }</span>

        }
        <span class="cov2" title="2">return result</span>
}
func isExistsAllResultFilesPrefixSampleId(outputDirectoryPath string, sampleId string) bool <span class="cov2" title="2">{
        result := true
        fn := filepath.Join(outputDirectoryPath, sampleId)
        for _, extension := range []string{".autosome_PAR_ploidy_2.g.vcf.gz",
                ".autosome_PAR_ploidy_2.g.vcf.gz.bcftools-stats",
                ".autosome_PAR_ploidy_2.g.vcf.gz.bcftools-stats.log",
                ".autosome_PAR_ploidy_2.g.vcf.gz.log",
                ".autosome_PAR_ploidy_2.g.vcf.gz.tbi",
                ".autosome_PAR_ploidy_2.g.vcf.gz.tbi.log",
                ".autosome_PAR_ploidy_2.g.vcf.log",
                ".bam.log",
                ".chrX_nonPAR_ploidy_1.g.vcf.gz",
                ".chrX_nonPAR_ploidy_1.g.vcf.gz.bcftools-stats",
                ".chrX_nonPAR_ploidy_1.g.vcf.gz.bcftools-stats.log",
                ".chrX_nonPAR_ploidy_1.g.vcf.gz.log",
                ".chrX_nonPAR_ploidy_1.g.vcf.gz.tbi",
                ".chrX_nonPAR_ploidy_1.g.vcf.gz.tbi.log",
                ".chrX_nonPAR_ploidy_1.g.vcf.log",
                ".chrX_nonPAR_ploidy_2.g.vcf.gz",
                ".chrX_nonPAR_ploidy_2.g.vcf.gz.bcftools-stats",
                ".chrX_nonPAR_ploidy_2.g.vcf.gz.bcftools-stats.log",
                ".chrX_nonPAR_ploidy_2.g.vcf.gz.log",
                ".chrX_nonPAR_ploidy_2.g.vcf.gz.tbi",
                ".chrX_nonPAR_ploidy_2.g.vcf.gz.tbi.log",
                ".chrX_nonPAR_ploidy_2.g.vcf.log",
                ".chrY_nonPAR_ploidy_1.g.vcf.gz",
                ".chrY_nonPAR_ploidy_1.g.vcf.gz.bcftools-stats",
                ".chrY_nonPAR_ploidy_1.g.vcf.gz.bcftools-stats.log",
                ".chrY_nonPAR_ploidy_1.g.vcf.gz.log",
                ".chrY_nonPAR_ploidy_1.g.vcf.gz.tbi",
                ".chrY_nonPAR_ploidy_1.g.vcf.gz.tbi.log",
                ".chrY_nonPAR_ploidy_1.g.vcf.log",
                ".cram",
                ".cram.autosome_PAR_ploidy_2.wgs_metrics",
                ".cram.autosome_PAR_ploidy_2.wgs_metrics.log",
                ".cram.chrX_nonPAR_ploidy_1.wgs_metrics",
                ".cram.chrX_nonPAR_ploidy_1.wgs_metrics.log",
                ".cram.chrX_nonPAR_ploidy_2.wgs_metrics",
                ".cram.chrX_nonPAR_ploidy_2.wgs_metrics.log",
                ".cram.chrY_nonPAR_ploidy_1.wgs_metrics",
                ".cram.chrY_nonPAR_ploidy_1.wgs_metrics.log",
                ".cram.collect_base_dist_by_cycle",
                ".cram.collect_base_dist_by_cycle.chart.pdf",
                ".cram.collect_base_dist_by_cycle.chart.png",
                ".cram.crai",
                ".cram.crai.log",
                ".cram.flagstat",
                ".cram.idxstats",
                ".cram.log",
                ".log",
                ".metrics.txt"} </span><span class="cov10" title="96">{
                // outputDirectoryPath/sampleId/sampleId.*
                // outputDirectoryPath/XX00000/XX00000.*
                targetFile := fn + "/" + sampleId + extension
                if _, err := os.Stat(targetFile); os.IsNotExist(err) </span><span class="cov1" title="1">{
                        fmt.Printf("Missing file [%s]\n", targetFile)
                        result = false
                }</span>

        }
        <span class="cov2" title="2">return result</span>
}

func getFileNameWithoutExtension(path string) string <span class="cov4" title="5">{
        return filepath.Base(path[:len(path)-len(filepath.Ext(path))])
}</span>

func checkSecondaryFilesExists(fn string) (bool, error) <span class="cov3" title="3">{
        // true is exist all files
        // false is some secodary files missing
        result := true
        for _, extension := range []string{".amb", ".ann", ".bwt", ".pac", ".sa", ".alt", ".fai"} </span><span class="cov7" title="21">{
                // Check file is exist
                if _, err := os.Stat(fn + extension); os.IsNotExist(err) </span><span class="cov1" title="1">{
                        fmt.Printf("Missing file [%s]\n", fn+extension)
                        result = false
                }</span>
        }
        // ^.dict
        <span class="cov3" title="3">dictfile := filepath.Join(filepath.Dir(fn), getFileNameWithoutExtension(fn)+".dict")
        if _, err := os.Stat(dictfile); os.IsNotExist(err) </span><span class="cov1" title="1">{
                fmt.Printf("Missing file [%s]\n", dictfile)
                result = false
        }</span>
        <span class="cov3" title="3">return result, nil</span>
}

func checkRunDataFile(fn string, fnmd5 string) (bool, error) <span class="cov2" title="2">{
        // Check file existance flag is set
        if fileExistsCheckFlag == false </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        // Check file is exist
        <span class="cov2" title="2">if _, err := os.Stat(fn); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return false, err
        }</span>
        // Check file hash
        <span class="cov2" title="2">if fileHashCheckFlag == false </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        // Check file hash value if specified
        <span class="cov2" title="2">result := true
        if fnmd5 != "" </span><span class="cov2" title="2">{
                md5, _ := md5File(fn)
                if fnmd5 != md5 </span><span class="cov1" title="1">{
                        result = false
                        fmt.Printf("expected: [%s]\n", fnmd5)
                        fmt.Printf("actual  : [%s]\n", md5)
                        fmt.Println("md5 is not match")
                }</span>
        }
        <span class="cov2" title="2">return result, nil</span>
}

/**
 * return value: true is fine, false is some thing wrong
 */
func checkRunData(runData *RunData) (bool, error) <span class="cov0" title="0">{
        result := false
        if runData.PEOrSE == "PE" </span><span class="cov0" title="0">{
                r1, _ := checkRunDataFile(runData.FQ1, runData.FQ1_MD5)
                r2, _ := checkRunDataFile(runData.FQ2, runData.FQ2_MD5)
                result = r1 &amp;&amp; r2
        }</span> else<span class="cov0" title="0"> {
                result, _ = checkRunDataFile(runData.FQ1, runData.FQ1_MD5)
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func outputReference(rss *referenceSchema) (string, error) <span class="cov0" title="0">{
        var byteBuf bytes.Buffer
        byteBuf.WriteString("")
        byteBuf.WriteString("reference:\n")
        byteBuf.WriteString("  class: File\n")
        byteBuf.WriteString(fmt.Sprintf("  path: %s\n", rss.Reference.Path))
        byteBuf.WriteString("  format: http://edamontology.org/format_1929\n")
        byteBuf.WriteString(fmt.Sprintf("sortsam_max_records_in_ram: %d\n", rss.SortsamMaxRecordsInRam))
        byteBuf.WriteString(fmt.Sprintf("sortsam_java_options: %s\n", rss.SortsamJavaOptions))
        byteBuf.WriteString(fmt.Sprintf("bwa_num_threads: %d\n", rss.BwaNumThreads))
        byteBuf.WriteString(fmt.Sprintf("bwa_bases_per_batch: %d\n", rss.BwaBasesPerBatch))
        byteBuf.WriteString(fmt.Sprintf("use_bqsr: %t\n", rss.UseBqsr))
        byteBuf.WriteString("dbsnp:\n")
        byteBuf.WriteString("  class: File\n")
        byteBuf.WriteString(fmt.Sprintf("  path: %s\n", rss.Dbsnp.Path))
        byteBuf.WriteString("  format: http://edamontology.org/format_3016\n")
        byteBuf.WriteString("mills:\n")
        byteBuf.WriteString("  class: File\n")
        byteBuf.WriteString(fmt.Sprintf("  path: %s\n", rss.Mills.Path))
        byteBuf.WriteString("  format: http://edamontology.org/format_3016\n")
        byteBuf.WriteString("known_indels:\n")
        byteBuf.WriteString("  class: File\n")
        byteBuf.WriteString(fmt.Sprintf("  path: %s\n", rss.KnownIndels.Path))
        byteBuf.WriteString("  format: http://edamontology.org/format_3016\n")
        byteBuf.WriteString(fmt.Sprintf("samtools_num_threads: %d\n", rss.SamtoolsNumThreads))
        byteBuf.WriteString(fmt.Sprintf("gatk4_HaplotypeCaller_num_threads: %d\n", rss.Gatk4HaplotypeCallerNumThreads))
        byteBuf.WriteString(fmt.Sprintf("bgzip_num_threads: %d\n", rss.BgzipNumThreads))
        byteBuf.WriteString("haplotypecaller_autosome_PAR_interval_bed:\n")
        byteBuf.WriteString("  class: File\n")
        byteBuf.WriteString(fmt.Sprintf("  path: %s\n", rss.HaplotypecallerAutosomePARIntervalBed.Path))
        byteBuf.WriteString("  format: http://edamontology.org/format_3584\n")
        byteBuf.WriteString("haplotypecaller_autosome_PAR_interval_list:\n")
        byteBuf.WriteString("  class: File\n")
        byteBuf.WriteString(fmt.Sprintf("  path: %s\n", rss.HaplotypecallerAutosomePARIntervalList.Path))
        byteBuf.WriteString("haplotypecaller_chrX_nonPAR_interval_bed:\n")
        byteBuf.WriteString("  class: File\n")
        byteBuf.WriteString(fmt.Sprintf("  path: %s\n", rss.HaplotypecallerChrXNonPARIntervalBed.Path))
        byteBuf.WriteString("  format: http://edamontology.org/format_3584\n")
        byteBuf.WriteString("haplotypecaller_chrX_nonPAR_interval_list:\n")
        byteBuf.WriteString("  class: File\n")
        byteBuf.WriteString(fmt.Sprintf("  path: %s\n", rss.HaplotypecallerChrXNonPARIntervalList.Path))
        byteBuf.WriteString("haplotypecaller_chrY_nonPAR_interval_bed:\n")
        byteBuf.WriteString("  class: File\n")
        byteBuf.WriteString(fmt.Sprintf("  path: %s\n", rss.HaplotypecallerChrYNonPARIntervalBed.Path))
        byteBuf.WriteString("  format: http://edamontology.org/format_3584\n")
        byteBuf.WriteString("haplotypecaller_chrY_nonPAR_interval_list:\n")
        byteBuf.WriteString("  class: File\n")
        byteBuf.WriteString(fmt.Sprintf("  path: %s\n", rss.HaplotypecallerChrYNonPARIntervalList.Path))

        return byteBuf.String(), nil
}</span>

// call per sample
func outputJobFile(s *Sample, rss *referenceSchema) (string, error) <span class="cov0" title="0">{
        //
        var byteBuf bytes.Buffer

        // count SE and PE entry
        numOfSE := 0
        numOfPE := 0
        for _, t := range s.RunList </span><span class="cov0" title="0">{
                if t.RunData.PEOrSE == "SE" </span><span class="cov0" title="0">{
                        numOfSE = numOfSE + 1
                }</span>
                <span class="cov0" title="0">if t.RunData.PEOrSE == "PE" </span><span class="cov0" title="0">{
                        numOfPE = numOfPE + 1
                }</span>
        }
        //
        <span class="cov0" title="0">byteBuf.WriteString(fmt.Sprintf("sample_id: %s\n", s.SampleId))
        if numOfPE == 0 </span><span class="cov0" title="0">{
                byteBuf.WriteString("runlist_pe: []\n")
        }</span> else<span class="cov0" title="0"> {
                byteBuf.WriteString("runlist_pe:\n")
                for _, t := range s.RunList </span><span class="cov0" title="0">{
                        if t.RunData.PEOrSE != "PE" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">byteBuf.WriteString(fmt.Sprintf("  - run_id: %s\n", t.RunId))
                        byteBuf.WriteString("    platform_name: ILLUMINA\n")
                        byteBuf.WriteString("    fastq1:\n")
                        byteBuf.WriteString("      class: File\n")
                        byteBuf.WriteString(fmt.Sprintf("      path: %s\n", t.RunData.FQ1))
                        byteBuf.WriteString("      format: http://edamontology.org/format_1930\n")
                        byteBuf.WriteString("    fastq2:\n")
                        byteBuf.WriteString("      class: File\n")
                        byteBuf.WriteString(fmt.Sprintf("      path: %s\n", t.RunData.FQ2))
                        byteBuf.WriteString("      format: http://edamontology.org/format_1930\n")</span>
                }
        }
        <span class="cov0" title="0">if numOfSE == 0 </span><span class="cov0" title="0">{
                byteBuf.WriteString("runlist_se: []\n")
        }</span> else<span class="cov0" title="0"> {
                byteBuf.WriteString("runlist_se:\n")
                for _, t := range s.RunList </span><span class="cov0" title="0">{
                        if t.RunData.PEOrSE != "SE" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">byteBuf.WriteString(fmt.Sprintf("  - run_id: %s\n", t.RunId))
                        byteBuf.WriteString("    platform_name: ILLUMINA\n")
                        byteBuf.WriteString("    fastq1:\n")
                        byteBuf.WriteString("      class: File\n")
                        byteBuf.WriteString(fmt.Sprintf("      path: %s\n", t.RunData.FQ1))
                        byteBuf.WriteString("      format: http://edamontology.org/format_1930\n")</span>
                }
        }

        <span class="cov0" title="0">return byteBuf.String(), nil</span>
}

func createJobFile(ss *simpleSchema, rss *referenceSchema) error <span class="cov0" title="0">{
        for _, s := range ss.SampleList </span><span class="cov0" title="0">{
                // create file
                //
                filename := fmt.Sprintf("%s_jobfile.yaml", s.SampleId)
                file, err := os.Create(filename)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer file.Close()
                writer := bufio.NewWriter(file)
                // output reference data to job file per each sampleID
                referenceData, _ := outputReference(rss)
                if _, err := writer.WriteString(referenceData); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">sampleData, _ := outputJobFile(s, rss)
                if _, err := writer.WriteString(sampleData); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Flush
                <span class="cov0" title="0">writer.Flush()</span>

        }
        <span class="cov0" title="0">return nil</span>
}

func execCWL(outputDirectoryPath string, workflowFilePath string, sampleId string) string <span class="cov0" title="0">{
        // execute toil
        //p, _ := os.Getwd()
        // c1 := exec.Command("toil-cwl-runner", "--maxDisk", "248G", "--maxMemory", "64G", "--defaultMemory", "32000", "--defaultDisk", "32000", "--workDir", p, "--disableCaching", "--jobStore", "./"+sampleId+"-jobstore", "--outdir", "./"+sampleId, "--stats", "--cleanWorkDir", "never", "--batchSystem", "slurm", "--retryCount", "1", "--singularity", "--logFile", sampleId+".log", "per-sample/Workflows/per-sample.cwl", sampleId+"_jobfile.yaml")
        c1 := exec.Command("toil-cwl-runner", "--maxDisk", "248G", "--maxMemory", "64G", "--defaultMemory", "32000", "--defaultDisk", "32000", "--disableCaching", "--jobStore", outputDirectoryPath+"/jobstores/"+sampleId+"-jobstore", "--outdir", outputDirectoryPath+"/"+sampleId, "--stats", "--batchSystem", "slurm", "--retryCount", "1", "--singularity", "--logFile", outputDirectoryPath+"/logs/"+sampleId+".log", workflowFilePath, sampleId+"_jobfile.yaml")
        // set environment value if needed
        //c1.Env = append(os.Environ(), "TOIL_SLURM_ARGS=\"-w node[1-9]\"")
        //
        stdoutfile, _ := os.Create(outputDirectoryPath + "/toil-outputs/" + sampleId + "-stdout.txt")
        defer stdoutfile.Close()
        c1.Stdout = stdoutfile
        //
        stderrfile, _ := os.Create(outputDirectoryPath + "/toil-outputs/" + sampleId + "-stderr.txt")
        defer stderrfile.Close()
        c1.Stderr = stderrfile
        //
        c1.Start()
        c1.Wait()
        // output exitcode
        exitcodefile, _ := os.Create(outputDirectoryPath + "/toil-outputs/" + sampleId + "-exitcode.txt")
        defer exitcodefile.Close()
        exitCode := c1.ProcessState.ExitCode()
        exitcodefile.WriteString(fmt.Sprintf("%d", exitCode))
        //
        stdoutwriter := bufio.NewWriter(stdoutfile)
        defer stdoutwriter.Flush()
        //
        stderrwriter := bufio.NewWriter(stderrfile)
        defer stderrwriter.Flush()

        //
        return ""
}</span>

func buildVersionString(version, revision, date string) string <span class="cov2" title="2">{
        result := fmt.Sprintf("Version: %s-%s (built at %s)\n", version, revision, date)
        return result
}</span>

var dryrunFlag bool
var helpFlag bool
var versionFlag bool
var fileExistsCheckFlag bool
var fileHashCheckFlag bool

func main() <span class="cov0" title="0">{
        flag.BoolVarP(&amp;dryrunFlag, "dry-run", "n", false, "Dry-run, do not execute acutal command")
        flag.BoolVarP(&amp;helpFlag, "help", "h", false, "Show help message")
        flag.BoolVarP(&amp;versionFlag, "version", "v", false, "Show version")
        flag.BoolVarP(&amp;fileExistsCheckFlag, "file-exists-check", "", true, "Check file exists")
        flag.BoolVarP(&amp;fileHashCheckFlag, "file-hash-check", "", true, "Check file hash value")
        flag.Parse()

        if helpFlag </span><span class="cov0" title="0">{
                fmt.Printf(buildVersionString(version, revision, date))
                flag.PrintDefaults()
                return
        }</span>
        <span class="cov0" title="0">if versionFlag </span><span class="cov0" title="0">{
                fmt.Printf(buildVersionString(version, revision, date))
                return
        }</span>

        //return

        <span class="cov0" title="0">path, err := filepath.Abs("./")

        // MUST must be canonical
        schemaLoader := gojsonschema.NewReferenceLoader("file://" + path + "/" + os.Args[1])
        // MUST must be canonical
        documentLoader := gojsonschema.NewReferenceLoader("file://" + path + "/" + os.Args[2])

        result, err := gojsonschema.Validate(schemaLoader, documentLoader)
        if err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }

        <span class="cov0" title="0">if result.Valid() </span><span class="cov0" title="0">{
                fmt.Printf("The document is valid\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("The document is not valid. see errors :\n")
                for _, desc := range result.Errors() </span><span class="cov0" title="0">{
                        fmt.Printf("- %s\n", desc)
                }</span>
        }
        <span class="cov0" title="0">fmt.Println("Load sample")
        raw, err := ioutil.ReadFile(os.Args[2])
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err.Error())
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">var ss simpleSchema

        json.Unmarshal(raw, &amp;ss)
        fmt.Println("Load end")

        // validate
        checkResult := false
        for _, s := range ss.SampleList </span><span class="cov0" title="0">{
                //fmt.Printf("Check index: %d, SampleId: %s\n", i, s.SampleId)
                for j, t := range s.RunList </span><span class="cov0" title="0">{
                        r1, _ := checkRunData(&amp;t.RunData)
                        checkResult = checkResult || r1
                        if !r1 </span><span class="cov0" title="0">{
                                fmt.Println("Some error found. Not exist or Hash value error")
                                fmt.Printf("Check index: %d, RunId: %s\n", j, t.RunId)
                                fmt.Printf("pe or se: [%s]\n", t.RunData.PEOrSE)
                                fmt.Printf("fq1: [%s]\n", t.RunData.FQ1)
                                fmt.Printf("fq2: [%s]\n", t.RunData.FQ2)
                                fmt.Printf("result=%t\n", r1)
                        }</span>
                }
        }
        <span class="cov0" title="0">if !checkResult </span><span class="cov0" title="0">{
                fmt.Println("some thing wrong. do not execute")
                return
        }</span>
        // reference config validate

        // MUST must be canonical
        <span class="cov0" title="0">rschemaLoader := gojsonschema.NewReferenceLoader("file://" + path + "/" + os.Args[3])
        // MUST must be canonical
        rdocumentLoader := gojsonschema.NewReferenceLoader("file://" + path + "/" + os.Args[4])

        rresult, err := gojsonschema.Validate(rschemaLoader, rdocumentLoader)
        if err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }

        <span class="cov0" title="0">if rresult.Valid() </span><span class="cov0" title="0">{
                fmt.Printf("The reference config document is valid\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("The reference config document is not valid. see errors :\n")
                for _, desc := range rresult.Errors() </span><span class="cov0" title="0">{
                        fmt.Printf("- %s\n", desc)
                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">fmt.Println("Load sample")
        rraw, err := ioutil.ReadFile(os.Args[4])
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err.Error())
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">var rss referenceSchema

        json.Unmarshal(rraw, &amp;rss)
        fmt.Println("Load end")

        // if dryrunFlag {
        //         fmt.Println("Dry-run flag is set")
        //         return
        // }
        //
        secondaryFilesCheck, err := checkSecondaryFilesExists(rss.Reference.Path)
        if !secondaryFilesCheck </span><span class="cov0" title="0">{
                fmt.Println("Some secondary file is missing")
                return
        }</span>

        // Set output directory path
        <span class="cov0" title="0">workflowFilePath := rss.WorkflowFile.Path
        if !strings.HasPrefix(workflowFilePath, "http://") </span><span class="cov0" title="0">{
                if !strings.HasPrefix(workflowFilePath, "https://") </span><span class="cov0" title="0">{
                        // currently check local filesystem only
                        if _, err := os.Stat(workflowFilePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                                fmt.Printf("Missing workflow file [%s]\n", workflowFilePath)
                                os.Exit(1)
                        }</span>
                }
        }

        // Set output directory path
        <span class="cov0" title="0">outputDirectoryPath := rss.OutputDirectory.Path
        // Create output directory
        // if not create , show error message and exit
        if err := os.MkdirAll(outputDirectoryPath, 0755); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                fmt.Println("cannot create output directory")
                return
        }</span>
        <span class="cov0" title="0">if err := os.MkdirAll(outputDirectoryPath+"/toil-outputs", 0755); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                fmt.Println("cannot create toil outputs directory")
                return
        }</span>
        <span class="cov0" title="0">if err := os.MkdirAll(outputDirectoryPath+"/logs", 0755); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                fmt.Println("cannot create logs directory")
                return
        }</span>
        <span class="cov0" title="0">if err := os.MkdirAll(outputDirectoryPath+"/jobstores", 0755); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                fmt.Println("cannot create jobstores directory")
                return
        }</span>
        // copy sample_sheet file
        <span class="cov0" title="0">original_sample_sheet, err := os.Open(os.Args[2])
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">defer original_sample_sheet.Close()
        copied_sample_sheet, err := os.Create(outputDirectoryPath + "/" + original_sample_sheet.Name())
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">defer copied_sample_sheet.Close()
        _, err = io.Copy(copied_sample_sheet, original_sample_sheet)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        // copy config file
        <span class="cov0" title="0">original_configfile, err := os.Open(os.Args[4])
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">defer original_configfile.Close()
        copied_configfile, err := os.Create(outputDirectoryPath + "/" + original_configfile.Name())
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">defer copied_configfile.Close()
        _, err = io.Copy(copied_configfile, original_configfile)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // create job file for CWL
        <span class="cov0" title="0">createJobFile(&amp;ss, &amp;rss)

        // dry-run

        // exec and wait
        var eg errgroup.Group
        executeCount := 0
        for i, s := range ss.SampleList </span><span class="cov0" title="0">{
                isExecute := false
                // Check SampleId result directory is exist
                if _, err := os.Stat(outputDirectoryPath + "/" + s.SampleId); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        // SampleId result directory is missing
                        // so this id must be executed
                        isExecute = true
                }</span> else<span class="cov0" title="0"> {
                        // check all result file is found or not
                        // SampleId prefix files check
                        check1 := isExistsAllResultFilesPrefixSampleId(outputDirectoryPath, s.SampleId)
                        if !check1 </span><span class="cov0" title="0">{
                                isExecute = true
                        }</span>
                        // RunID prefix files check
                        <span class="cov0" title="0">for _, r := range s.RunList </span><span class="cov0" title="0">{
                                check2 := isExistsAllResultFilesPrefixRunId(outputDirectoryPath+"/"+s.SampleId, r.RunId)
                                if !check2 </span><span class="cov0" title="0">{
                                        isExecute = true
                                }</span>
                        }
                        //fmt.Printf("index: %d, SampleId: %s will be Execute new.\n", i, s.SampleId)
                }
                <span class="cov0" title="0">if isExecute </span><span class="cov0" title="0">{
                        executeCount += 1

                        fmt.Printf("index: %d, SampleId: %s will be Execute new.\n", i, s.SampleId)
                        sampleId := s.SampleId
                        if !dryrunFlag </span><span class="cov0" title="0">{
                                eg.Go(func() error </span><span class="cov0" title="0">{
                                        execCWL(outputDirectoryPath, workflowFilePath, sampleId)
                                        return nil
                                }</span>)
                        }
                }
        }
        <span class="cov0" title="0">if dryrunFlag </span><span class="cov0" title="0">{
                fmt.Printf("[%d/%d] task will be executed.\n", executeCount, len(ss.SampleList))
        }</span>

        // for i, s := range ss.SampleList {
        //         fmt.Printf("index: %d, SampleId: %s\n", i, s.SampleId)
        //         sampleId := s.SampleId
        //         eg.Go(func() error {
        //                 // TODO check exit status
        //                 execCWL(outputDirectoryPath, workflowFilePath, sampleId)
        //                 return nil
        //         })
        // }

        <span class="cov0" title="0">if err := eg.Wait(); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">fmt.Println("fin")</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
